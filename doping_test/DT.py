from TestResult import *
from TestCaseSelection import *
from SimpleTrace import *
from tool.doping_test import Output

class DT(object):
	"""Implementation for DT from the paper"""
	def __init__(self, test_case_selection, output_verifier, system_under_test):
		super(DT, self).__init__()
		self.test_case_selection = test_case_selection
		self.output_verifier = output_verifier
		self.system_under_test = system_under_test
		
		self.history = SimpleTrace()

	def advance(self):
		# pick one of the three options of the algorithm
		option = self.test_case_selection.get_next_option(self.history)

		if option == TestCaseSelection.OPTION_PASS:
			# the test is passed
			return TestResult(TestResult.PASSED, self.history)

		elif option == TestCaseSelection.OPTION_INPUT:
			# get the next input from test case selection
			next_input = self.test_case_selection.get_next_input(self.history)

			# pass input to SUT and check if SUT provided an output in the meantime
			system_output = self.system_under_test.pass_input(next_input)

			if system_output != None:
				# the input is cancelled, because the output generated by the SUT must be processed first.
				# the new output may influence test case selection

				# we add the output to the history
				self.history.extend(system_output)

				# Check if the output is accepted (this is the case, if no counter example can be found)
				counterexample = self.output_verifier.check_output(self.history)

				if counterexample != None:
					# the test failed, because we received an invalid output
					return TestResult(TestResult.FAILED, self.history, counterexample)

			else: # system_output == None
				# the input has been accepted, so we add it to the history
				self.history.extend(next_input)

				# return None to indicate that the test is neither passed nor failed
				return None

		elif option == TestCaseSelection.OPTION_OUTPUT:
			# we wait for the next output or quiescence
			system_output = self.system_under_test.receive_output()

			if system_output == None:
				# we observe quiescence

				# we add the quiescence to the history
				self.history.extend(Output(None))

				# Check if quiescence is accepted (this is the case, if no counter example can be found)
				counterexample = self.output_verifier.check_quiescence(self.history)
				
				if counterexample != None:
					# the test failed, because quiescence is not allowed here
					return TestResult(TestResult.FAILED, self.history, counterexample)

			else:
				# we add the verified output to the history
				self.history.extend(system_output)

				# Check if the output is accepted (this is the case, if no counter example can be found)
				counterexample = self.output_verifier.check_output(self.history)

				if counterexample != None:
					# the test failed, because we received an invalid output
					return TestResult(TestResult.FAILED, self.history, counterexample)

			# return None to indicate that the test is neither passed nor failed
			return None

		else:
			raise Exception('Invalid option!')


	def test(self, boundary):
		test_result = None
		# instead of recursion, we iterate `b` times and call `advance` to perform the next step of Algorithm 1 in the paper
		for i in xrange(0, boundary):
			test_result = self.advance()

			if test_result != None:
				# We have a decision by DT. Skip the remaining test iterations and return the result.
				return test_result

			# Test result is inconclusive, so continue

		if test_result == None:
			# if the test result is still inconclusive, we pick option 1 of DT, letting the test pass
			test_result = TestResult(TestResult.PASSED, self.history)

		return test_result






